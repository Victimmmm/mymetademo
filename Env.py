# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hyRdNcS99E1Dcg2heIqmnIp-wQcRuuFq
"""
from abc import ABC
from gym import Env
from gym.spaces import Discrete
import numpy as np
import math
import random

# Paper para
Number_of_VSPs = 1
Number_of_UAVs = 5
t_sens = 5  # second
dm = 170
f_n = 7  # giga/cycle
B0 = 10e-6
Data_process_complex = 1000
Noise_vari = 10e-11
# length of packet
q = 5  
# Computing capacity
f_max = 20  
# Bandwidth e
Wmn = 10e6  
p_comm_mn = 0.5
Sensing_rate = random.choice([960 * 540, 1280 * 720, 1920 * 1080, 2560 * 1440])
To = 1.2
gamma = 1
Alpha = 0.5
# Latency requirement
t_Latency_req = 5  
# minimum second that metaverse user need for example 3 user need 5,12,9 at t_req
t_req = min(5, 9, 12)  
# total bit
Q = 0  
# L is the number of parts that the main task is divided into

task_granularity = 10
task_size=1e10


def Communication_Latency():
    Q_m = Sensing_rate * q * t_sens
    h_m = B0 * (dm ** -gamma)
    R_m = Wmn * math.log2((1 + (p_comm_mn * h_m / (Noise_vari * To))))
    t_comm_m = Q_m / R_m
    return t_comm_m


def Processing(Q_Local, f_v, f_e, gamma_EC):
    Q_offload = Q - Q_Local
    t_local = Data_process_complex * Q_Local / f_v
    R = Wmn * math.log2((1 + 10*pow(10,gamma_EC/10)))
    t_comm = Q_offload / R
    t_offload = Data_process_complex * Q_offload / f_e
    t_edge = t_comm + t_offload
    return t_edge, t_local


def total_latency(t_edge, t_local):
    t_comp = max(t_local, t_edge)
    list_t_sen_comp = list()
    for i in range(1, Number_of_UAVs+1):
        list_t_sen_comp.append(Communication_Latency() + t_sens)
    t_tot = t_comp + max(list_t_sen_comp)
    return t_tot


class ModelEnv(Env, ABC):
    def __init__(self, t_sens, Wmn, Number_of_UAVs, L, t_req, V=1):
        self.t_sens = t_sens
        self.Q_local = None
        self.Q_offload = None
        self.Number_of_UAVs = Number_of_UAVs  # number of UAV
        self.gamma_EC = None
        self.f_v = None
        self.f_e = None
        self.Q = 0
        self.V = V  # number of VSP
        self.L = L
        self.action_space = Discrete(self.L + 1)
        self.t_req = t_req
        self.ban = Wmn  # bandwidth between UAV and VSP
        self.t_tot = 0
        self.state = np.array([self.Q, None, self.t_tot, self.t_req, None, None])

    def get_state(self):
        for i in range(self.Number_of_UAVs):
            Q_m = q * Sensing_rate * t_sens
            self.Q += Q_m
        self.gamma_EC = random.choice([-3, 0, 3, 6, 9])
        self.f_v = self.f_e = 10  # Giga cycles/ second
        self.t_req = t_req
        self.state = np.array([self.Q, self.gamma_EC, self.t_tot, self.t_req, self.f_v, self.f_e])
        return self.state

    def step(self, action: int):
        action = self.L
        Q, gamma_EC, t_tot, t_req, f_v, f_e = self.state
        # the weight which is decided to offload
        beta = action / self.L
        self.Q_offload = beta * Q
        self.Q_local = self.Q - self.Q_offload
        t_e1 = Processing(self.Q_local, self.f_v, self.f_e, self.gamma_EC)[0]
        t_l1 = Processing(self.Q_local, self.f_v, self.f_e, self.gamma_EC)[1]
        self.t_tot = total_latency(t_e1, t_l1)

        # calculate the penalty
        penalty = 0
        if self.t_tot <= t_req:
            penalty = penalty + 10
        else:
            penalty -= 2
        done = bool(beta <= 1)
        return self.state, penalty, done, {}

    def reset(self, **kwargs):
        self.Q = 0
        self.t_tot = 0
        self.t_req = 0
        self.state = np.array([self.Q, None, self.t_tot, self.t_req, None, None])
